// ============================ eth crypto  ============================
[Custom]
typedef string PackedEthSignature;

// ============================ zklink crypto  ============================
[Error]
enum ZkSignerError {
    "CustomError",
    "InvalidSignature",
    "InvalidPrivKey",
    "InvalidSeed",
    "InvalidPubkey",
    "InvalidPubkeyHash",
    "PackedETHSignatureError",
};

[Custom]
typedef string PackedPublicKey;
[Custom]
typedef string PackedSignature;
[Custom]
typedef string PubKeyHash;

interface ZkLinkSigner {
    [Throws=ZkSignerError]
    constructor();
    [Throws=ZkSignerError,Name=new_from_seed]
    constructor([ByRef] sequence<u8> seed);
    [Throws=ZkSignerError,Name=new_from_hex_eth_signer]
    constructor([ByRef] string eth_hex_private_key);
    [Throws=ZkSignerError,Name=new_from_bytes]
    constructor([ByRef] sequence<u8> slice);
    PackedPublicKey public_key();
    [Throws=ZkSignerError]
    ZkLinkSignature sign_musig([ByRef] sequence<u8> msg);
};

dictionary ZkLinkSignature {
    PackedPublicKey public_key;
    PackedSignature signature;
};

// ============================  basic types  ============================
[Error]
enum TypeError {
    "InvalidAddress",
    "InvalidTxHash",
    "NotStartWithZerox",
    "SizeMismatch",
    "DecodeFromHexErr",
};

[Custom]
typedef u32 SlotId;
[Custom]
typedef u32 TokenId;
[Custom]
typedef u16 PairId;
[Custom]
typedef u32 TimeStamp;
[Custom]
typedef u32 AccountId;
[Custom]
typedef u32 BlockNumber;
[Custom]
typedef u32 Nonce;
[Custom]
typedef u64 PriorityOpId;
[Custom]
typedef u64 EthBlockId;
[Custom]
typedef u8 ChainId;
[Custom]
typedef u8 SubAccountId;
[Custom]
typedef string H256;
[Custom]
typedef string BigUint;
[Custom]
typedef string ZkLinkAddress;
[Custom]
typedef string TxHash;

// ============================  transaction types  ============================

interface Deposit {
    constructor(
        ChainId from_chain_id,
        ZkLinkAddress from,
        SubAccountId sub_account_id,
        ZkLinkAddress to,
        TokenId l2_target_token,
        TokenId l1_source_token,
        BigUint amount,
        u64 serial_id,
        H256 eth_hash
    );
    sequence<u8> get_bytes();
};

interface Withdraw {
    constructor(
        AccountId account_id,
        SubAccountId sub_account_id,
        ChainId to_chain_id,
        ZkLinkAddress to,
        TokenId l2_source_token,
        TokenId l1_target_token,
        BigUint amount,
        BigUint fee,
        Nonce nonce,
        boolean fast_withdraw,
        u16 withdraw_fee_ratio,
        TimeStamp ts
    );
    sequence<u8> get_bytes();
    boolean is_validate();
    string get_ethereum_sign_message_part([ByRef] string token_symbol);
    string get_ethereum_sign_message([ByRef] string token_symbol);
};

interface ChangePubKey {
    constructor(
        ChainId chain_id,
        AccountId account_id,
        SubAccountId sub_account_id,
        PubKeyHash new_pk_hash,
        TokenId fee_token,
        BigUint fee,
        Nonce nonce,
        ZkLinkSignature ?signature,
        PackedEthSignature ?eth_signature,
        TimeStamp ts
    );
    sequence<u8> get_bytes();
    boolean is_validate();
    boolean is_onchain();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
    ZkLinkSignature signature();
    string get_ethereum_sign_message_part([ByRef] string token_symbol, u8 decimal);
};

interface ForcedExit {
    constructor(
        ChainId to_chain_id,
        AccountId initiator_account_id,
        SubAccountId initiator_sub_account_id,
        ZkLinkAddress target,
        SubAccountId target_sub_account_id,
        TokenId l2_source_token,
        TokenId l1_target_token,
        Nonce nonce,
        BigUint exit_amount,
        TimeStamp ts
    );
    sequence<u8> get_bytes();
    ZkLinkSignature signature();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
};

interface Transfer {
    constructor(
        AccountId account_id,
        ZkLinkAddress to,
        SubAccountId from_sub_account_id,
        SubAccountId to_sub_account_id,
        TokenId token,
        BigUint amount,
        BigUint fee,
        Nonce nonce,
        TimeStamp ts
    );
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
    string get_ethereum_sign_message_part([ByRef] string token_symbol);
    string get_ethereum_sign_message([ByRef] string token_symbol);
};


interface Order {
    constructor(
        AccountId account_id,
        SubAccountId sub_account_id,
        SlotId slot_id,
        Nonce nonce,
        TokenId base_token_id,
        TokenId quote_token_id,
        BigUint amount,
        BigUint price,
        boolean is_sell,
        u8 fee_ratio1,
        u8 fee_ratio2
    );
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
    string get_ethereum_sign_message([ByRef] string quote_token, [ByRef] string based_token, u8 decimals);
};

// ============================  namespace ============================
namespace zklink_sdk {
    [Throws=ZkSignerError]
    boolean verify_musig(ZkLinkSignature signature, [ByRef] sequence<u8> msg);
    PubKeyHash get_public_key_hash(PackedPublicKey public_key);
    [Throws=ZkSignerError]
    ChangePubKey sign_tx_change_pub_key(ChangePubKey tx, ZkLinkSigner signer);
};

