// ============================  basic types  ============================
[Error]
enum TypeError {
    "InvalidAddress",
    "InvalidTxHash",
    "NotStartWithZerox",
    "SizeMismatch",
    "DecodeFromHexErr",
    "TooBigInteger",
};

[Custom]
typedef u32 SlotId;
[Custom]
typedef u32 TokenId;
[Custom]
typedef u16 PairId;
[Custom]
typedef u32 TimeStamp;
[Custom]
typedef u32 AccountId;
[Custom]
typedef u32 BlockNumber;
[Custom]
typedef u32 Nonce;
[Custom]
typedef u64 PriorityOpId;
[Custom]
typedef u64 EthBlockId;
[Custom]
typedef u8 ChainId;
[Custom]
typedef u8 SubAccountId;
[Custom]
typedef string H256;
[Custom]
typedef string BigUint;
[Custom]
typedef string ZkLinkAddress;
[Custom]
typedef string TxHash;
[Custom]
typedef string TxEthSignature;

// ============================ tx builder  ============================
dictionary ChangePubKeyBuilder {
    ChainId chain_id;
    AccountId account_id;
    SubAccountId sub_account_id;
    PubKeyHash new_pubkey_hash;
    TokenId fee_token;
    BigUint fee;
    Nonce nonce;
    PackedEthSignature ?eth_signature;
    TimeStamp ts;
};

dictionary TransferBuilder {
    AccountId account_id;
    ZkLinkAddress to_address;
    SubAccountId from_sub_account_id;
    SubAccountId to_sub_account_id;
    TokenId token;
    BigUint amount;
    BigUint fee;
    Nonce nonce;
    TimeStamp timestamp;
};


dictionary DepositBuilder {
    ZkLinkAddress from_address;
    ZkLinkAddress to_address;
    ChainId from_chain_id;
    SubAccountId sub_account_id;
    TokenId l2_target_token;
    TokenId l1_source_token;
    BigUint amount;
    u64 serial_id;
    H256 eth_hash;
};


dictionary WithdrawBuilder {
    AccountId account_id;
    SubAccountId sub_account_id;
    ChainId to_chain_id;
    ZkLinkAddress to_address;
    TokenId l2_source_token;
    TokenId l1_target_token;
    BigUint amount;
    BigUint fee;
    Nonce nonce;
    boolean fast_withdraw;
    u16 withdraw_fee_ratio;
    TimeStamp timestamp;
};

dictionary ForecedExitBuilder {
    ChainId to_chain_id;
    AccountId initiator_account_id;
    SubAccountId initiator_sub_account_id;
    ZkLinkAddress target;
    SubAccountId target_sub_account_id;
    TokenId l2_source_token;
    TokenId l1_target_token;
    Nonce initiator_nonce;
    BigUint exit_amount;
    TimeStamp ts;
};

dictionary FullExitBuilder {
    ChainId to_chain_id;
    AccountId account_id;
    SubAccountId sub_account_id;
    ZkLinkAddress exit_address;
    TokenId l2_source_token;
    TokenId l1_target_token;
    u64 serial_id;
    H256 eth_hash;
};


dictionary OrderMatchingBuilder {
    AccountId account_id;
    SubAccountId sub_account_id;
    Order taker;
    Order maker;
    BigUint fee;
    TokenId fee_token;
    BigUint expect_base_amount;
    BigUint expect_quote_amount;
};


// ============================  transaction types  ============================
dictionary Create2Data {
    ZkLinkAddress creator_address;
    H256 salt_arg;
    H256 code_hash;
};

[Enum]
interface ChangePubKeyAuthRequest {
    OnChain();
    EthECDSA();
    EthCreate2(Create2Data data);
};

[Enum]
interface ChangePubKeyAuthData {
    OnChain();
    EthECDSA(PackedEthSignature eth_signature);
    EthCreate2(Create2Data data);
};

interface Deposit {
    constructor(DepositBuilder builder);
    sequence<u8> get_bytes();
    sequence<u8> tx_hash();
    string json_str();
};

interface Withdraw {
    constructor(WithdrawBuilder builder);
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    sequence<u8> tx_hash();
    string json_str();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
    string get_ethereum_sign_message([ByRef] string token_symbol);
    [Throws=ZkSignerError]
    PackedEthSignature  eth_signature(PrivateKeySigner eth_signer, [ByRef] string l2_source_token_symbol);
};

interface ChangePubKey {
    constructor(ChangePubKeyBuilder builder);
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    sequence<u8> tx_hash();
    string json_str();
    boolean is_validate();
    boolean is_onchain();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
};

interface ForcedExit {
    constructor(ForecedExitBuilder builder);
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    sequence<u8> tx_hash();
    string json_str();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
};


interface FullExit {
    constructor(FullExitBuilder builder);
    sequence<u8> get_bytes();
    sequence<u8> tx_hash();
    string json_str();
    boolean is_validate();
};

interface Transfer {
    constructor(TransferBuilder builder);
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    sequence<u8> tx_hash();
    string json_str();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
    string get_ethereum_sign_message([ByRef] string token_symbol);
    [Throws=ZkSignerError]
    TxEthSignature eth_signature(PrivateKeySigner eth_signer, [ByRef]string token_symbol);
};


interface Order {
    constructor(
        AccountId account_id,
        SubAccountId sub_account_id,
        SlotId slot_id,
        Nonce nonce,
        TokenId base_token_id,
        TokenId quote_token_id,
        BigUint amount,
        BigUint price,
        boolean is_sell,
        u8 fee_ratio1,
        u8 fee_ratio2
    );
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    string json_str();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
    string get_ethereum_sign_message([ByRef] string quote_token, [ByRef] string based_token, u8 decimals);
};

interface OrderMatching {
    constructor( OrderMatchingBuilder builder);
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    sequence<u8> tx_hash();
    string json_str();
    boolean is_validate();
        [Throws=ZkSignerError]
        boolean is_signature_valid();
};


// ============================ eth crypto  ============================
[Error]
enum EthSignerError {
    "InvalidEthSigner",
    "MissingEthPrivateKey",
    "MissingEthSigner",
    "SigningFailed",
    "UnlockingFailed",
    "InvalidRawTx",
    "Eip712Failed",
    "NoSigningKey",
    "DefineAddress",
    "RecoverAddress",
    "LengthMismatched",
    "CryptoError",
    "InvalidSignatureStr",
    "CustomError",
};

[Custom]
typedef string PackedEthSignature;

interface PrivateKeySigner {
    [Throws=EthSignerError]
    constructor([ByRef] string private_key);
    [Throws=EthSignerError]
    PackedEthSignature sign_message([ByRef] sequence<u8> message);
};

// ============================ zklink crypto  ============================
[Error]
enum ZkSignerError {
    "CustomError",
    "InvalidSignature",
    "InvalidPrivKey",
    "InvalidSeed",
    "InvalidPubkey",
    "InvalidPubkeyHash",
    "PackedETHSignatureError",
};

[Custom]
typedef string PackedPublicKey;
[Custom]
typedef string PackedSignature;
[Custom]
typedef string PubKeyHash;

interface ZkLinkSigner {
    [Throws=ZkSignerError]
    constructor();
    [Throws=ZkSignerError,Name=new_from_seed]
    constructor([ByRef] sequence<u8> seed);
    [Throws=ZkSignerError,Name=new_from_hex_eth_signer]
    constructor([ByRef] string eth_hex_private_key);
    [Throws=ZkSignerError,Name=new_from_bytes]
    constructor([ByRef] sequence<u8> slice);
    PackedPublicKey public_key();
    [Throws=ZkSignerError]
    ZkLinkSignature sign_musig([ByRef] sequence<u8> msg);
};

dictionary ZkLinkSignature {
    PackedPublicKey public_key;
    PackedSignature signature;
};




// ============================  iterface ============================

[Error]
enum SignError {
    "EthSigningError",
    "ZkSigningError",
    "IncorrectTx",
};

// ============================  rpc response ============================
[Custom]
typedef u64 TimeStampMicro;

// ============================  namespace ============================
namespace zklink_sdk {
    [Throws=ZkSignerError]
    boolean verify_musig(ZkLinkSignature signature, [ByRef] sequence<u8> msg);
    PubKeyHash get_public_key_hash(PackedPublicKey public_key);


    string json_str_of_zklink_signature(ZkLinkSignature signature);
    // network
    string zklink_main_net_url();
    string zklink_test_net_url();

    // for change pubkey
    [Throws=SignError]
    PackedEthSignature eth_signature_of_change_pubkey(u32 l1_client_id, ChangePubKey tx, PrivateKeySigner eth_signer, ZkLinkAddress main_contract);
    [Throws=SignError]
    ChangePubKey create_signed_change_pubkey(ZkLinkSigner zklink_signer, ChangePubKey tx, ChangePubKeyAuthData eth_auth_data);

    [Throws=ZkSignerError]
    ForcedExit create_signed_forced_exit(ZkLinkSigner zklink_signer, ForcedExit tx);
    [Throws=ZkSignerError]
    Order create_signed_order(ZkLinkSigner zklink_signer, Order order);
    [Throws=ZkSignerError]
    OrderMatching create_signed_order_matching(ZkLinkSigner signer, OrderMatching tx);
    [Throws=SignError]
    Transfer create_signed_transfer(ZkLinkSigner zklink_signer, Transfer tx);
    [Throws=SignError]
    Withdraw create_signed_withdraw(ZkLinkSigner zklink_signer, Withdraw tx);

    [Throws=SignError]
    string build_change_pubkey_request_with_create2data([ByRef] string private_key, ChangePubKeyBuilder builder, Create2Data create2data);
    [Throws=SignError]
    string build_change_pubkey_request_with_onchain_auth_data([ByRef] string private_key, ChangePubKeyBuilder builder);
    [Throws=SignError]
    string build_change_pubkey_request_with_eth_ecdsa_auth_data([ByRef] string private_key, ChangePubKeyBuilder builder, u32 l1_client_id, ZkLinkAddress main_contract_address);
    [Throws=SignError]
    string build_transfer_request([ByRef] string private_key, TransferBuilder builder, [ByRef] string token_symbol);
    [Throws=SignError]
    string build_deposit_request(DepositBuilder builder);
    [Throws=SignError]
    string build_withdraw_request([ByRef] string private_key, WithdrawBuilder builder);
    [Throws=SignError]
    string build_forced_exit_request([ByRef] string private_key, ForecedExitBuilder builder);
    [Throws=SignError]
    string build_full_exit_request(FullExitBuilder builder);
    [Throws=SignError]
    string build_order_matching_request([ByRef] string private_key, OrderMatchingBuilder builder);
};

