// ============================  basic types  ============================
[Error]
enum TypeError {
    "InvalidAddress",
    "InvalidTxHash",
    "NotStartWithZerox",
    "SizeMismatch",
    "DecodeFromHexErr",
    "TooBigInteger",
};

[Custom]
typedef u32 SlotId;
[Custom]
typedef u32 TokenId;
[Custom]
typedef u16 PairId;
[Custom]
typedef u32 TimeStamp;
[Custom]
typedef u32 AccountId;
[Custom]
typedef u32 BlockNumber;
[Custom]
typedef u32 Nonce;
[Custom]
typedef u64 PriorityOpId;
[Custom]
typedef u64 EthBlockId;
[Custom]
typedef u8 ChainId;
[Custom]
typedef u8 SubAccountId;
[Custom]
typedef string H256;
[Custom]
typedef string BigUint;
[Custom]
typedef string ZkLinkAddress;
[Custom]
typedef string TxHash;

// ============================  transaction types  ============================
dictionary Create2Data {
    ZkLinkAddress creator_address;
    H256 salt_arg;
    H256 code_hash;
};

[Enum]
interface ChangePubKeyAuthRequest {
    OnChain();
    EthECDSA();
    EthCreate2(Create2Data data);
};

[Enum]
interface ChangePubKeyAuthData {
    OnChain();
    EthECDSA(PackedEthSignature eth_signature);
    EthCreate2(Create2Data data);
};

interface Deposit {
    constructor(
        ChainId from_chain_id,
        ZkLinkAddress from,
        SubAccountId sub_account_id,
        ZkLinkAddress to,
        TokenId l2_target_token,
        TokenId l1_source_token,
        BigUint amount,
        u64 serial_id,
        H256 eth_hash
    );
    sequence<u8> get_bytes();
    string json_str();
};

interface Withdraw {
    constructor(
        AccountId account_id,
        SubAccountId sub_account_id,
        ChainId to_chain_id,
        ZkLinkAddress to,
        TokenId l2_source_token,
        TokenId l1_target_token,
        BigUint amount,
        BigUint fee,
        Nonce nonce,
        boolean fast_withdraw,
        u16 withdraw_fee_ratio,
        TimeStamp ts
    );
    sequence<u8> get_bytes();
    string json_str();
    boolean is_validate();
    string get_ethereum_sign_message_part([ByRef] string token_symbol);
    string get_ethereum_sign_message([ByRef] string token_symbol);
};

interface ChangePubKey {
    constructor(
        ChainId chain_id,
        AccountId account_id,
        SubAccountId sub_account_id,
        PubKeyHash new_pk_hash,
        TokenId fee_token,
        BigUint fee,
        Nonce nonce,
        PackedEthSignature ?eth_signature,
        TimeStamp ts
    );
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    string json_str();
    boolean is_validate();
    boolean is_onchain();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
    string get_ethereum_sign_message_part([ByRef] string token_symbol, u8 decimal);
};

interface ForcedExit {
    constructor(
        ChainId to_chain_id,
        AccountId initiator_account_id,
        SubAccountId initiator_sub_account_id,
        ZkLinkAddress target,
        SubAccountId target_sub_account_id,
        TokenId l2_source_token,
        TokenId l1_target_token,
        Nonce nonce,
        BigUint exit_amount,
        TimeStamp ts
    );
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    string json_str();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
};


interface FullExit {
    constructor(
        ChainId to_chain_id,
        AccountId account_id,
        SubAccountId sub_account_id,
        ZkLinkAddress exit_address,
        TokenId l2_source_token,
        TokenId l1_target_token,
        u64 serial_id,
        H256 eth_hash
    );
    sequence<u8> get_bytes();
    string json_str();
    boolean is_validate();
};

interface Transfer {
    constructor(
        AccountId account_id,
        ZkLinkAddress to,
        SubAccountId from_sub_account_id,
        SubAccountId to_sub_account_id,
        TokenId token,
        BigUint amount,
        BigUint fee,
        Nonce nonce,
        TimeStamp ts
    );
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    string json_str();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
    string get_ethereum_sign_message_part([ByRef] string token_symbol);
    string get_ethereum_sign_message([ByRef] string token_symbol);
};


interface Order {
    constructor(
        AccountId account_id,
        SubAccountId sub_account_id,
        SlotId slot_id,
        Nonce nonce,
        TokenId base_token_id,
        TokenId quote_token_id,
        BigUint amount,
        BigUint price,
        boolean is_sell,
        u8 fee_ratio1,
        u8 fee_ratio2
    );
    ZkLinkSignature signature();
    sequence<u8> get_bytes();
    string json_str();
    boolean is_validate();
    [Throws=ZkSignerError]
    boolean is_signature_valid();
    string get_ethereum_sign_message([ByRef] string quote_token, [ByRef] string based_token, u8 decimals);
};

interface OrderMatching {
    constructor(
        AccountId account_id,
        SubAccountId sub_accoount_id,
        Order taker,
        Order maker,
        BigUint fee,
        TokenId fee_token,
        BigUint expect_base_amount,
        BigUint expect_quote_amount
    );
};

// ============================ eth crypto  ============================
[Error]
enum EthSignerError {
    "InvalidEthSigner",
    "MissingEthPrivateKey",
    "MissingEthSigner",
    "SigningFailed",
    "UnlockingFailed",
    "InvalidRawTx",
    "Eip712Failed",
    "NoSigningKey",
    "DefineAddress",
    "RecoverAddress",
    "LengthMismatched",
    "CryptoError",
    "InvalidSignatureStr",
    "CustomError",
};

[Custom]
typedef string PackedEthSignature;

interface PrivateKeySigner {
    [Throws=EthSignerError]
    constructor([ByRef] string private_key);
    [Throws=EthSignerError]
    PackedEthSignature sign_message([ByRef] sequence<u8> message);
};

// ============================ zklink crypto  ============================
[Error]
enum ZkSignerError {
    "CustomError",
    "InvalidSignature",
    "InvalidPrivKey",
    "InvalidSeed",
    "InvalidPubkey",
    "InvalidPubkeyHash",
    "PackedETHSignatureError",
};

[Custom]
typedef string PackedPublicKey;
[Custom]
typedef string PackedSignature;
[Custom]
typedef string PubKeyHash;

interface ZkLinkSigner {
    [Throws=ZkSignerError]
    constructor();
    [Throws=ZkSignerError,Name=new_from_seed]
    constructor([ByRef] sequence<u8> seed);
    [Throws=ZkSignerError,Name=new_from_hex_eth_signer]
    constructor([ByRef] string eth_hex_private_key);
    [Throws=ZkSignerError,Name=new_from_bytes]
    constructor([ByRef] sequence<u8> slice);
    PackedPublicKey public_key();
    [Throws=ZkSignerError]
    ZkLinkSignature sign_musig([ByRef] sequence<u8> msg);
};

dictionary ZkLinkSignature {
    PackedPublicKey public_key;
    PackedSignature signature;
};




// ============================  iterface ============================

[Error]
enum SignError {
    "EthSigningError",
    "ZkSigningError",
    "IncorrectTx",
};


[Custom]
typedef string TxSignature;

// ============================  rpc response ============================
[Custom]
typedef u64 TimeStampMicro;

// ============================  namespace ============================
namespace zklink_sdk {
    [Throws=ZkSignerError]
    boolean verify_musig(ZkLinkSignature signature, [ByRef] sequence<u8> msg);
    PubKeyHash get_public_key_hash(PackedPublicKey public_key);


    string json_str_of_zklink_signature(ZkLinkSignature signature);

    // for change pubkey
    [Throws=SignError]
    PackedEthSignature eth_signature_of_change_pubkey(u32 l1_client_id, ChangePubKey tx, PrivateKeySigner eth_signer, ZkLinkAddress main_contract);
    [Throws=SignError]
    ZkLinkSignature create_submitter_signature([ByRef] sequence<u8> tx_bytes, ZkLinkSigner zklink_signer);
    [Throws=SignError]
    ChangePubKey create_signed_change_pubkey(ZkLinkSigner zklink_signer, ChangePubKey tx, ChangePubKeyAuthData eth_auth_data);

    [Throws=ZkSignerError]
    TxSignature sign_forced_exit(ZkLinkSigner zklink_signer, ForcedExit tx);
    [Throws=ZkSignerError]
    Order signed_order(ZkLinkSigner zklink_signer, Order order);
    [Throws=ZkSignerError]
    TxSignature sign_order_matching(ZkLinkSigner signer, OrderMatching tx);
    [Throws=SignError]
    TxSignature sign_transfer(PrivateKeySigner eth_signer, ZkLinkSigner zklink_signer, Transfer tx, string token_symbol);
    [Throws=SignError]
    TxSignature sign_withdraw(PrivateKeySigner eth_signer, ZkLinkSigner zklink_signer, Withdraw tx, string token_symbol);
};

