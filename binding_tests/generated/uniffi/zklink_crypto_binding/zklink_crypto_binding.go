package zklink_crypto_binding

/*


// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

#include <stdbool.h>
#include <stdint.h>

// The following structs are used to implement the lowest level
// of the FFI, and thus useful to multiple uniffied crates.
// We ensure they are declared exactly once, with a header guard, UNIFFI_SHARED_H.
#ifdef UNIFFI_SHARED_H
	// We also try to prevent mixing versions of shared uniffi header structs.
	// If you add anything to the #else block, you must increment the version suffix in UNIFFI_SHARED_HEADER_V4
	#ifndef UNIFFI_SHARED_HEADER_V4
		#error Combining helper code from multiple versions of uniffi is not supported
	#endif // ndef UNIFFI_SHARED_HEADER_V4
#else
#define UNIFFI_SHARED_H
#define UNIFFI_SHARED_HEADER_V4
// ⚠️ Attention: If you change this #else block (ending in `#endif // def UNIFFI_SHARED_H`) you *must* ⚠️
// ⚠️ increment the version suffix in all instances of UNIFFI_SHARED_HEADER_V4 in this file.           ⚠️

typedef struct RustBuffer {
	int32_t capacity;
	int32_t len;
	uint8_t *data;
} RustBuffer;

typedef int32_t (*ForeignCallback)(uint64_t, int32_t, RustBuffer, RustBuffer *);

typedef struct ForeignBytes {
	int32_t len;
	const uint8_t *data;
} ForeignBytes;

// Error definitions
typedef struct RustCallStatus {
	int8_t code;
	RustBuffer errorBuf;
} RustCallStatus;

// ⚠️ Attention: If you change this #else block (ending in `#endif // def UNIFFI_SHARED_H`) you *must* ⚠️
// ⚠️ increment the version suffix in all instances of UNIFFI_SHARED_HEADER_V4 in this file.           ⚠️
#endif // def UNIFFI_SHARED_H

void ffi_zklink_crypto_binding_baa4_PubKeyHash_object_free(
	void* ptr,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_PubKeyHash_zero(
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_PubKeyHash_from_hex(
	RustBuffer s,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_PubKeyHash_from_bytes(
	RustBuffer bytes,
	RustCallStatus* out_status
);

RustBuffer zklink_crypto_binding_baa4_PubKeyHash_as_hex(
	void* ptr,
	RustCallStatus* out_status
);

void ffi_zklink_crypto_binding_baa4_PackedPublicKey_object_free(
	void* ptr,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_PackedPublicKey_from_bytes(
	RustBuffer bytes,
	RustCallStatus* out_status
);

RustBuffer zklink_crypto_binding_baa4_PackedPublicKey_as_bytes(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer zklink_crypto_binding_baa4_PackedPublicKey_as_hex(
	void* ptr,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_PackedPublicKey_public_key_hash(
	void* ptr,
	RustCallStatus* out_status
);

void ffi_zklink_crypto_binding_baa4_PackedSignature_object_free(
	void* ptr,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_PackedSignature_from_bytes(
	RustBuffer bytes,
	RustCallStatus* out_status
);

RustBuffer zklink_crypto_binding_baa4_PackedSignature_as_bytes(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer zklink_crypto_binding_baa4_PackedSignature_as_hex(
	void* ptr,
	RustCallStatus* out_status
);

void ffi_zklink_crypto_binding_baa4_ZkLinkSignature_object_free(
	void* ptr,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_ZkLinkSignature_from_bytes(
	RustBuffer bytes,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_ZkLinkSignature_from_hex(
	RustBuffer s,
	RustCallStatus* out_status
);

RustBuffer zklink_crypto_binding_baa4_ZkLinkSignature_as_bytes(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer zklink_crypto_binding_baa4_ZkLinkSignature_as_hex(
	void* ptr,
	RustCallStatus* out_status
);

int8_t zklink_crypto_binding_baa4_ZkLinkSignature_verify_musig(
	void* ptr,
	RustBuffer msg,
	RustCallStatus* out_status
);

void ffi_zklink_crypto_binding_baa4_ZkLinkSigner_object_free(
	void* ptr,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_ZkLinkSigner_new(
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_ZkLinkSigner_new_from_seed(
	RustBuffer seed,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_ZkLinkSigner_new_from_hex_eth_signer(
	RustBuffer eth_hex_private_key,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_ZkLinkSigner_new_from_bytes(
	RustBuffer slice,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_ZkLinkSigner_get_public_key(
	void* ptr,
	RustCallStatus* out_status
);

void* zklink_crypto_binding_baa4_ZkLinkSigner_sign_musig(
	void* ptr,
	RustBuffer msg,
	RustCallStatus* out_status
);

RustBuffer ffi_zklink_crypto_binding_baa4_rustbuffer_alloc(
	int32_t size,
	RustCallStatus* out_status
);

RustBuffer ffi_zklink_crypto_binding_baa4_rustbuffer_from_bytes(
	ForeignBytes bytes,
	RustCallStatus* out_status
);

void ffi_zklink_crypto_binding_baa4_rustbuffer_free(
	RustBuffer buf,
	RustCallStatus* out_status
);

RustBuffer ffi_zklink_crypto_binding_baa4_rustbuffer_reserve(
	RustBuffer buf,
	int32_t additional,
	RustCallStatus* out_status
);


*/
import "C"

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"math"
	"runtime"
	"sync/atomic"
	"unsafe"
)

type rustBuffer struct {
	capacity int
	length   int
	data     unsafe.Pointer
	self     C.RustBuffer
}

func fromCRustBuffer(crbuf C.RustBuffer) rustBuffer {
	return rustBuffer{
		capacity: int(crbuf.capacity),
		length:   int(crbuf.len),
		data:     unsafe.Pointer(crbuf.data),
		self:     crbuf,
	}
}

// asByteBuffer reads the full rust buffer and then converts read bytes to a new reader which makes
// it quite inefficient
// TODO: Return an implementation which reads only when needed
func (rb rustBuffer) asReader() *bytes.Reader {
	b := C.GoBytes(rb.data, C.int(rb.length))
	return bytes.NewReader(b)
}

func (rb rustBuffer) asCRustBuffer() C.RustBuffer {
	return C.RustBuffer{
		capacity: C.int(rb.capacity),
		len:      C.int(rb.length),
		data:     (*C.uchar)(unsafe.Pointer(rb.data)),
	}
}

func stringToCRustBuffer(str string) C.RustBuffer {
	b := []byte(str)
	cs := C.CString(str)
	return C.RustBuffer{
		capacity: C.int(len(b)),
		len:      C.int(len(b)),
		data:     (*C.uchar)(unsafe.Pointer(cs)),
	}
}

func (rb rustBuffer) free() {
	rustCall(func(status *C.RustCallStatus) bool {
		C.ffi_zklink_crypto_binding_baa4_rustbuffer_free(rb.self, status)
		return false
	})
}

type bufLifter[GoType any] interface {
	lift(value C.RustBuffer) GoType
}

type bufLowerer[GoType any] interface {
	lower(value GoType) C.RustBuffer
}

type ffiConverter[GoType any, FfiType any] interface {
	lift(value FfiType) GoType
	lower(value GoType) FfiType
}

type bufReader[GoType any] interface {
	read(reader io.Reader) GoType
}

type bufWriter[GoType any] interface {
	write(writer io.Writer, value GoType)
}

type ffiRustBufConverter[GoType any, FfiType any] interface {
	ffiConverter[GoType, FfiType]
	bufReader[GoType]
}

func lowerIntoRustBuffer[GoType any](bufWriter bufWriter[GoType], value GoType) C.RustBuffer {
	// This might be not the most efficient way but it does not require knowing allocation size
	// beforehand
	var buffer bytes.Buffer
	bufWriter.write(&buffer, value)

	bytes, err := io.ReadAll(&buffer)
	if err != nil {
		panic(fmt.Errorf("reading written data: %w", err))
	}

	return stringToCRustBuffer(string(bytes))
}

func liftFromRustBuffer[GoType any](bufReader bufReader[GoType], rbuf rustBuffer) GoType {
	defer rbuf.free()
	reader := rbuf.asReader()
	item := bufReader.read(reader)
	if reader.Len() > 0 {
		// TODO: Remove this
		leftover, _ := io.ReadAll(reader)
		panic(fmt.Errorf("Junk remaining in buffer after lifting: %s", string(leftover)))
	}
	return item
}

func rustCallWithError[U any](converter bufLifter[error], callback func(*C.RustCallStatus) U) (U, error) {
	var status C.RustCallStatus
	returnValue := callback(&status)
	switch status.code {
	case 0:
		return returnValue, nil
	case 1:
		return returnValue, converter.lift(status.errorBuf)
	case 2:
		// when the rust code sees a panic, it tries to construct a rustbuffer
		// with the message.  but if that code panics, then it just sends back
		// an empty buffer.
		if status.errorBuf.len > 0 {
			panic(fmt.Errorf("%s", FfiConverterstringINSTANCE.lift(status.errorBuf)))
		} else {
			panic(fmt.Errorf("Rust panicked while handling Rust panic"))
		}
	default:
		return returnValue, fmt.Errorf("unknown status code: %d", status.code)
	}
}

func rustCall[U any](callback func(*C.RustCallStatus) U) U {
	returnValue, err := rustCallWithError(nil, callback)
	if err != nil {
		panic(err)
	}
	return returnValue
}

func writeInt8(writer io.Writer, value int8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint8(writer io.Writer, value uint8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt16(writer io.Writer, value int16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint16(writer io.Writer, value uint16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt32(writer io.Writer, value int32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint32(writer io.Writer, value uint32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt64(writer io.Writer, value int64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint64(writer io.Writer, value uint64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat32(writer io.Writer, value float32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat64(writer io.Writer, value float64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func readInt8(reader io.Reader) int8 {
	var result int8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint8(reader io.Reader) uint8 {
	var result uint8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt16(reader io.Reader) int16 {
	var result int16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint16(reader io.Reader) uint16 {
	var result uint16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt32(reader io.Reader) int32 {
	var result int32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint32(reader io.Reader) uint32 {
	var result uint32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt64(reader io.Reader) int64 {
	var result int64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint64(reader io.Reader) uint64 {
	var result uint64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat32(reader io.Reader) float32 {
	var result float32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat64(reader io.Reader) float64 {
	var result float64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func init() {

}

type FfiConverteruint8 struct{}

var FfiConverteruint8INSTANCE = FfiConverteruint8{}

func (FfiConverteruint8) lower(value uint8) C.uint8_t {
	return C.uint8_t(value)
}

func (FfiConverteruint8) write(writer io.Writer, value uint8) {
	writeUint8(writer, value)
}

func (FfiConverteruint8) lift(value C.uint8_t) uint8 {
	return uint8(value)
}

func (FfiConverteruint8) read(reader io.Reader) uint8 {
	return readUint8(reader)
}

type FfiDestroyeruint8 struct{}

func (FfiDestroyeruint8) destroy(_ uint8) {}

type FfiConverterbool struct{}

var FfiConverterboolINSTANCE = FfiConverterbool{}

func (FfiConverterbool) lower(value bool) C.int8_t {
	if value {
		return C.int8_t(1)
	}
	return C.int8_t(0)
}

func (FfiConverterbool) write(writer io.Writer, value bool) {
	if value {
		writeInt8(writer, 1)
	} else {
		writeInt8(writer, 0)
	}
}

func (FfiConverterbool) lift(value C.int8_t) bool {
	return value != 0
}

func (FfiConverterbool) read(reader io.Reader) bool {
	return readInt8(reader) != 0
}

type FfiDestroyerbool struct{}

func (FfiDestroyerbool) destroy(_ bool) {}

type FfiConverterstring struct{}

var FfiConverterstringINSTANCE = FfiConverterstring{}

func (FfiConverterstring) lift(cRustBuf C.RustBuffer) string {
	reader := fromCRustBuffer(cRustBuf).asReader()
	b, err := io.ReadAll(reader)
	if err != nil {
		panic(fmt.Errorf("reading reader: %w", err))
	}
	return string(b)
}

func (FfiConverterstring) read(reader io.Reader) string {
	length := readInt32(reader)
	buffer := make([]byte, length)
	read_length, err := reader.Read(buffer)
	if err != nil {
		panic(err)
	}
	if read_length != int(length) {
		panic(fmt.Errorf("bad read length when reading string, expected %d, read %d", length, read_length))
	}
	return string(buffer)
}

func (FfiConverterstring) lower(value string) C.RustBuffer {
	return stringToCRustBuffer(value)
}

func (FfiConverterstring) write(writer io.Writer, value string) {
	if len(value) > math.MaxInt32 {
		panic("String is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	write_length, err := io.WriteString(writer, value)
	if err != nil {
		panic(err)
	}
	if write_length != len(value) {
		panic(fmt.Errorf("bad write length when writing string, expected %d, written %d", len(value), write_length))
	}
}

type FfiDestroyerstring struct{}

func (FfiDestroyerstring) destroy(_ string) {}

// Below is an implementation of synchronization requirements outlined in the link.
// https://github.com/mozilla/uniffi-rs/blob/0dc031132d9493ca812c3af6e7dd60ad2ea95bf0/uniffi_bindgen/src/bindings/kotlin/templates/ObjectRuntime.kt#L31

type FfiObject struct {
	pointer      unsafe.Pointer
	callCounter  atomic.Int64
	freeFunction func(unsafe.Pointer, *C.RustCallStatus)
	destroyed    atomic.Bool
}

func newFfiObject(pointer unsafe.Pointer, freeFunction func(unsafe.Pointer, *C.RustCallStatus)) FfiObject {
	return FfiObject{
		pointer:      pointer,
		freeFunction: freeFunction,
	}
}

func (ffiObject *FfiObject) incrementPointer(debugName string) unsafe.Pointer {
	for {
		counter := ffiObject.callCounter.Load()
		if counter <= -1 {
			panic(fmt.Errorf("%v object has already been destroyed", debugName))
		}
		if counter == math.MaxInt64 {
			panic(fmt.Errorf("%v object call counter would overflow", debugName))
		}
		if ffiObject.callCounter.CompareAndSwap(counter, counter+1) {
			break
		}
	}

	return ffiObject.pointer
}

func (ffiObject *FfiObject) decrementPointer() {
	if ffiObject.callCounter.Add(-1) == -1 {
		ffiObject.freeRustArcPtr()
	}
}

func (ffiObject *FfiObject) destroy() {
	if ffiObject.destroyed.CompareAndSwap(false, true) {
		if ffiObject.callCounter.Add(-1) == -1 {
			ffiObject.freeRustArcPtr()
		}
	}
}

func (ffiObject *FfiObject) freeRustArcPtr() {
	rustCall(func(status *C.RustCallStatus) int32 {
		ffiObject.freeFunction(ffiObject.pointer, status)
		return 0
	})
}

type PackedPublicKey struct {
	ffiObject FfiObject
}

func PackedPublicKeyFromBytes(bytes []uint8) (*PackedPublicKey, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_PackedPublicKey_from_bytes(FfiConverterSequenceuint8INSTANCE.lower(bytes), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *PackedPublicKey
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterPackedPublicKeyINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}

func (_self *PackedPublicKey) AsBytes() []uint8 {
	_pointer := _self.ffiObject.incrementPointer("*PackedPublicKey")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterSequenceuint8INSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.zklink_crypto_binding_baa4_PackedPublicKey_as_bytes(
			_pointer, _uniffiStatus)
	}))

}
func (_self *PackedPublicKey) AsHex() string {
	_pointer := _self.ffiObject.incrementPointer("*PackedPublicKey")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterstringINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.zklink_crypto_binding_baa4_PackedPublicKey_as_hex(
			_pointer, _uniffiStatus)
	}))

}
func (_self *PackedPublicKey) PublicKeyHash() *PubKeyHash {
	_pointer := _self.ffiObject.incrementPointer("*PackedPublicKey")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterPubKeyHashINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_PackedPublicKey_public_key_hash(
			_pointer, _uniffiStatus)
	}))

}

func (object *PackedPublicKey) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterPackedPublicKey struct{}

var FfiConverterPackedPublicKeyINSTANCE = FfiConverterPackedPublicKey{}

func (c FfiConverterPackedPublicKey) lift(pointer unsafe.Pointer) *PackedPublicKey {
	result := &PackedPublicKey{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.ffi_zklink_crypto_binding_baa4_PackedPublicKey_object_free(pointer, status)
			}),
	}
	runtime.SetFinalizer(result, (*PackedPublicKey).Destroy)
	return result
}

func (c FfiConverterPackedPublicKey) read(reader io.Reader) *PackedPublicKey {
	return c.lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterPackedPublicKey) lower(value *PackedPublicKey) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*PackedPublicKey")
	defer value.ffiObject.decrementPointer()
	return pointer
}

func (c FfiConverterPackedPublicKey) write(writer io.Writer, value *PackedPublicKey) {
	writeUint64(writer, uint64(uintptr(c.lower(value))))
}

type FfiDestroyerPackedPublicKey struct{}

func (_ FfiDestroyerPackedPublicKey) destroy(value *PackedPublicKey) {
	value.Destroy()
}

type PackedSignature struct {
	ffiObject FfiObject
}

func PackedSignatureFromBytes(bytes []uint8) (*PackedSignature, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_PackedSignature_from_bytes(FfiConverterSequenceuint8INSTANCE.lower(bytes), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *PackedSignature
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterPackedSignatureINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}

func (_self *PackedSignature) AsBytes() []uint8 {
	_pointer := _self.ffiObject.incrementPointer("*PackedSignature")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterSequenceuint8INSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.zklink_crypto_binding_baa4_PackedSignature_as_bytes(
			_pointer, _uniffiStatus)
	}))

}
func (_self *PackedSignature) AsHex() string {
	_pointer := _self.ffiObject.incrementPointer("*PackedSignature")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterstringINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.zklink_crypto_binding_baa4_PackedSignature_as_hex(
			_pointer, _uniffiStatus)
	}))

}

func (object *PackedSignature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterPackedSignature struct{}

var FfiConverterPackedSignatureINSTANCE = FfiConverterPackedSignature{}

func (c FfiConverterPackedSignature) lift(pointer unsafe.Pointer) *PackedSignature {
	result := &PackedSignature{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.ffi_zklink_crypto_binding_baa4_PackedSignature_object_free(pointer, status)
			}),
	}
	runtime.SetFinalizer(result, (*PackedSignature).Destroy)
	return result
}

func (c FfiConverterPackedSignature) read(reader io.Reader) *PackedSignature {
	return c.lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterPackedSignature) lower(value *PackedSignature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*PackedSignature")
	defer value.ffiObject.decrementPointer()
	return pointer
}

func (c FfiConverterPackedSignature) write(writer io.Writer, value *PackedSignature) {
	writeUint64(writer, uint64(uintptr(c.lower(value))))
}

type FfiDestroyerPackedSignature struct{}

func (_ FfiDestroyerPackedSignature) destroy(value *PackedSignature) {
	value.Destroy()
}

type PubKeyHash struct {
	ffiObject FfiObject
}

func PubKeyHashZero() *PubKeyHash {

	return FfiConverterPubKeyHashINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_PubKeyHash_zero(_uniffiStatus)
	}))

}
func PubKeyHashFromHex(s string) (*PubKeyHash, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_PubKeyHash_from_hex(FfiConverterstringINSTANCE.lower(s), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *PubKeyHash
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterPubKeyHashINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func PubKeyHashFromBytes(bytes []uint8) (*PubKeyHash, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_PubKeyHash_from_bytes(FfiConverterSequenceuint8INSTANCE.lower(bytes), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *PubKeyHash
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterPubKeyHashINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}

func (_self *PubKeyHash) AsHex() string {
	_pointer := _self.ffiObject.incrementPointer("*PubKeyHash")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterstringINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.zklink_crypto_binding_baa4_PubKeyHash_as_hex(
			_pointer, _uniffiStatus)
	}))

}

func (object *PubKeyHash) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterPubKeyHash struct{}

var FfiConverterPubKeyHashINSTANCE = FfiConverterPubKeyHash{}

func (c FfiConverterPubKeyHash) lift(pointer unsafe.Pointer) *PubKeyHash {
	result := &PubKeyHash{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.ffi_zklink_crypto_binding_baa4_PubKeyHash_object_free(pointer, status)
			}),
	}
	runtime.SetFinalizer(result, (*PubKeyHash).Destroy)
	return result
}

func (c FfiConverterPubKeyHash) read(reader io.Reader) *PubKeyHash {
	return c.lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterPubKeyHash) lower(value *PubKeyHash) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*PubKeyHash")
	defer value.ffiObject.decrementPointer()
	return pointer
}

func (c FfiConverterPubKeyHash) write(writer io.Writer, value *PubKeyHash) {
	writeUint64(writer, uint64(uintptr(c.lower(value))))
}

type FfiDestroyerPubKeyHash struct{}

func (_ FfiDestroyerPubKeyHash) destroy(value *PubKeyHash) {
	value.Destroy()
}

type ZkLinkSignature struct {
	ffiObject FfiObject
}

func ZkLinkSignatureFromBytes(bytes []uint8) (*ZkLinkSignature, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_ZkLinkSignature_from_bytes(FfiConverterSequenceuint8INSTANCE.lower(bytes), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *ZkLinkSignature
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterZkLinkSignatureINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func ZkLinkSignatureFromHex(s string) (*ZkLinkSignature, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_ZkLinkSignature_from_hex(FfiConverterstringINSTANCE.lower(s), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *ZkLinkSignature
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterZkLinkSignatureINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}

func (_self *ZkLinkSignature) AsBytes() []uint8 {
	_pointer := _self.ffiObject.incrementPointer("*ZkLinkSignature")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterSequenceuint8INSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.zklink_crypto_binding_baa4_ZkLinkSignature_as_bytes(
			_pointer, _uniffiStatus)
	}))

}
func (_self *ZkLinkSignature) AsHex() string {
	_pointer := _self.ffiObject.incrementPointer("*ZkLinkSignature")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterstringINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.zklink_crypto_binding_baa4_ZkLinkSignature_as_hex(
			_pointer, _uniffiStatus)
	}))

}
func (_self *ZkLinkSignature) VerifyMusig(msg []uint8) (bool, error) {
	_pointer := _self.ffiObject.incrementPointer("*ZkLinkSignature")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.zklink_crypto_binding_baa4_ZkLinkSignature_verify_musig(
			_pointer, FfiConverterSequenceuint8INSTANCE.lower(msg), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue bool
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterboolINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}

func (object *ZkLinkSignature) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterZkLinkSignature struct{}

var FfiConverterZkLinkSignatureINSTANCE = FfiConverterZkLinkSignature{}

func (c FfiConverterZkLinkSignature) lift(pointer unsafe.Pointer) *ZkLinkSignature {
	result := &ZkLinkSignature{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.ffi_zklink_crypto_binding_baa4_ZkLinkSignature_object_free(pointer, status)
			}),
	}
	runtime.SetFinalizer(result, (*ZkLinkSignature).Destroy)
	return result
}

func (c FfiConverterZkLinkSignature) read(reader io.Reader) *ZkLinkSignature {
	return c.lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterZkLinkSignature) lower(value *ZkLinkSignature) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ZkLinkSignature")
	defer value.ffiObject.decrementPointer()
	return pointer
}

func (c FfiConverterZkLinkSignature) write(writer io.Writer, value *ZkLinkSignature) {
	writeUint64(writer, uint64(uintptr(c.lower(value))))
}

type FfiDestroyerZkLinkSignature struct{}

func (_ FfiDestroyerZkLinkSignature) destroy(value *ZkLinkSignature) {
	value.Destroy()
}

type ZkLinkSigner struct {
	ffiObject FfiObject
}

func NewZkLinkSigner() (*ZkLinkSigner, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_ZkLinkSigner_new(_uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *ZkLinkSigner
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterZkLinkSignerINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}

func ZkLinkSignerNewFromSeed(seed []uint8) (*ZkLinkSigner, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_ZkLinkSigner_new_from_seed(FfiConverterSequenceuint8INSTANCE.lower(seed), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *ZkLinkSigner
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterZkLinkSignerINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func ZkLinkSignerNewFromHexEthSigner(ethHexPrivateKey string) (*ZkLinkSigner, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_ZkLinkSigner_new_from_hex_eth_signer(FfiConverterstringINSTANCE.lower(ethHexPrivateKey), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *ZkLinkSigner
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterZkLinkSignerINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func ZkLinkSignerNewFromBytes(slice []uint8) (*ZkLinkSigner, error) {

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_ZkLinkSigner_new_from_bytes(FfiConverterSequenceuint8INSTANCE.lower(slice), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *ZkLinkSigner
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterZkLinkSignerINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}

func (_self *ZkLinkSigner) GetPublicKey() (*PackedPublicKey, error) {
	_pointer := _self.ffiObject.incrementPointer("*ZkLinkSigner")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_ZkLinkSigner_get_public_key(
			_pointer, _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *PackedPublicKey
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterPackedPublicKeyINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *ZkLinkSigner) SignMusig(msg []uint8) (*ZkLinkSignature, error) {
	_pointer := _self.ffiObject.incrementPointer("*ZkLinkSigner")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeZkSignerError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.zklink_crypto_binding_baa4_ZkLinkSigner_sign_musig(
			_pointer, FfiConverterSequenceuint8INSTANCE.lower(msg), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *ZkLinkSignature
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterZkLinkSignatureINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}

func (object *ZkLinkSigner) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterZkLinkSigner struct{}

var FfiConverterZkLinkSignerINSTANCE = FfiConverterZkLinkSigner{}

func (c FfiConverterZkLinkSigner) lift(pointer unsafe.Pointer) *ZkLinkSigner {
	result := &ZkLinkSigner{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.ffi_zklink_crypto_binding_baa4_ZkLinkSigner_object_free(pointer, status)
			}),
	}
	runtime.SetFinalizer(result, (*ZkLinkSigner).Destroy)
	return result
}

func (c FfiConverterZkLinkSigner) read(reader io.Reader) *ZkLinkSigner {
	return c.lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterZkLinkSigner) lower(value *ZkLinkSigner) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ZkLinkSigner")
	defer value.ffiObject.decrementPointer()
	return pointer
}

func (c FfiConverterZkLinkSigner) write(writer io.Writer, value *ZkLinkSigner) {
	writeUint64(writer, uint64(uintptr(c.lower(value))))
}

type FfiDestroyerZkLinkSigner struct{}

func (_ FfiDestroyerZkLinkSigner) destroy(value *ZkLinkSigner) {
	value.Destroy()
}

type ZkSignerError struct {
	err error
}

func (err ZkSignerError) Error() string {
	return fmt.Sprintf("ZkSignerError: %s", err.err.Error())
}

func (err ZkSignerError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrZkSignerErrorCustomError = fmt.Errorf("ZkSignerErrorCustomError")
var ErrZkSignerErrorInvalidSignature = fmt.Errorf("ZkSignerErrorInvalidSignature")
var ErrZkSignerErrorInvalidPrivKey = fmt.Errorf("ZkSignerErrorInvalidPrivKey")
var ErrZkSignerErrorInvalidSeed = fmt.Errorf("ZkSignerErrorInvalidSeed")
var ErrZkSignerErrorInvalidPubkey = fmt.Errorf("ZkSignerErrorInvalidPubkey")
var ErrZkSignerErrorInvalidPubkeyHash = fmt.Errorf("ZkSignerErrorInvalidPubkeyHash")
var ErrZkSignerErrorPackedEthSignatureError = fmt.Errorf("ZkSignerErrorPackedEthSignatureError")

// Variant structs
type ZkSignerErrorCustomError struct {
	message string
}

func NewZkSignerErrorCustomError() *ZkSignerError {
	return &ZkSignerError{
		err: &ZkSignerErrorCustomError{},
	}
}

func (err ZkSignerErrorCustomError) Error() string {
	return fmt.Sprintf("CustomError: %s", err.message)
}

func (self ZkSignerErrorCustomError) Is(target error) bool {
	return target == ErrZkSignerErrorCustomError
}

type ZkSignerErrorInvalidSignature struct {
	message string
}

func NewZkSignerErrorInvalidSignature() *ZkSignerError {
	return &ZkSignerError{
		err: &ZkSignerErrorInvalidSignature{},
	}
}

func (err ZkSignerErrorInvalidSignature) Error() string {
	return fmt.Sprintf("InvalidSignature: %s", err.message)
}

func (self ZkSignerErrorInvalidSignature) Is(target error) bool {
	return target == ErrZkSignerErrorInvalidSignature
}

type ZkSignerErrorInvalidPrivKey struct {
	message string
}

func NewZkSignerErrorInvalidPrivKey() *ZkSignerError {
	return &ZkSignerError{
		err: &ZkSignerErrorInvalidPrivKey{},
	}
}

func (err ZkSignerErrorInvalidPrivKey) Error() string {
	return fmt.Sprintf("InvalidPrivKey: %s", err.message)
}

func (self ZkSignerErrorInvalidPrivKey) Is(target error) bool {
	return target == ErrZkSignerErrorInvalidPrivKey
}

type ZkSignerErrorInvalidSeed struct {
	message string
}

func NewZkSignerErrorInvalidSeed() *ZkSignerError {
	return &ZkSignerError{
		err: &ZkSignerErrorInvalidSeed{},
	}
}

func (err ZkSignerErrorInvalidSeed) Error() string {
	return fmt.Sprintf("InvalidSeed: %s", err.message)
}

func (self ZkSignerErrorInvalidSeed) Is(target error) bool {
	return target == ErrZkSignerErrorInvalidSeed
}

type ZkSignerErrorInvalidPubkey struct {
	message string
}

func NewZkSignerErrorInvalidPubkey() *ZkSignerError {
	return &ZkSignerError{
		err: &ZkSignerErrorInvalidPubkey{},
	}
}

func (err ZkSignerErrorInvalidPubkey) Error() string {
	return fmt.Sprintf("InvalidPubkey: %s", err.message)
}

func (self ZkSignerErrorInvalidPubkey) Is(target error) bool {
	return target == ErrZkSignerErrorInvalidPubkey
}

type ZkSignerErrorInvalidPubkeyHash struct {
	message string
}

func NewZkSignerErrorInvalidPubkeyHash() *ZkSignerError {
	return &ZkSignerError{
		err: &ZkSignerErrorInvalidPubkeyHash{},
	}
}

func (err ZkSignerErrorInvalidPubkeyHash) Error() string {
	return fmt.Sprintf("InvalidPubkeyHash: %s", err.message)
}

func (self ZkSignerErrorInvalidPubkeyHash) Is(target error) bool {
	return target == ErrZkSignerErrorInvalidPubkeyHash
}

type ZkSignerErrorPackedEthSignatureError struct {
	message string
}

func NewZkSignerErrorPackedEthSignatureError() *ZkSignerError {
	return &ZkSignerError{
		err: &ZkSignerErrorPackedEthSignatureError{},
	}
}

func (err ZkSignerErrorPackedEthSignatureError) Error() string {
	return fmt.Sprintf("PackedEthSignatureError: %s", err.message)
}

func (self ZkSignerErrorPackedEthSignatureError) Is(target error) bool {
	return target == ErrZkSignerErrorPackedEthSignatureError
}

type FfiConverterTypeZkSignerError struct{}

var FfiConverterTypeZkSignerErrorINSTANCE = FfiConverterTypeZkSignerError{}

func (c FfiConverterTypeZkSignerError) lift(cErrBuf C.RustBuffer) error {
	errBuf := fromCRustBuffer(cErrBuf)
	return liftFromRustBuffer[error](c, errBuf)
}

func (c FfiConverterTypeZkSignerError) lower(value *ZkSignerError) C.RustBuffer {
	return lowerIntoRustBuffer[*ZkSignerError](c, value)
}

func (c FfiConverterTypeZkSignerError) read(reader io.Reader) error {
	errorID := readUint32(reader)

	message := FfiConverterstringINSTANCE.read(reader)
	switch errorID {
	case 1:
		return &ZkSignerError{&ZkSignerErrorCustomError{message}}
	case 2:
		return &ZkSignerError{&ZkSignerErrorInvalidSignature{message}}
	case 3:
		return &ZkSignerError{&ZkSignerErrorInvalidPrivKey{message}}
	case 4:
		return &ZkSignerError{&ZkSignerErrorInvalidSeed{message}}
	case 5:
		return &ZkSignerError{&ZkSignerErrorInvalidPubkey{message}}
	case 6:
		return &ZkSignerError{&ZkSignerErrorInvalidPubkeyHash{message}}
	case 7:
		return &ZkSignerError{&ZkSignerErrorPackedEthSignatureError{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterTypeZkSignerError.read()", errorID))
	}

}

func (c FfiConverterTypeZkSignerError) write(writer io.Writer, value *ZkSignerError) {
	switch variantValue := value.err.(type) {
	case *ZkSignerErrorCustomError:
		writeInt32(writer, 1)
	case *ZkSignerErrorInvalidSignature:
		writeInt32(writer, 2)
	case *ZkSignerErrorInvalidPrivKey:
		writeInt32(writer, 3)
	case *ZkSignerErrorInvalidSeed:
		writeInt32(writer, 4)
	case *ZkSignerErrorInvalidPubkey:
		writeInt32(writer, 5)
	case *ZkSignerErrorInvalidPubkeyHash:
		writeInt32(writer, 6)
	case *ZkSignerErrorPackedEthSignatureError:
		writeInt32(writer, 7)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterTypeZkSignerError.write", value))
	}
}

type FfiConverterSequenceuint8 struct{}

var FfiConverterSequenceuint8INSTANCE = FfiConverterSequenceuint8{}

func (c FfiConverterSequenceuint8) lift(cRustBuf C.RustBuffer) []uint8 {
	return liftFromRustBuffer[[]uint8](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterSequenceuint8) read(reader io.Reader) []uint8 {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]uint8, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverteruint8INSTANCE.read(reader))
	}
	return result
}

func (c FfiConverterSequenceuint8) lower(value []uint8) C.RustBuffer {
	return lowerIntoRustBuffer[[]uint8](c, value)
}

func (c FfiConverterSequenceuint8) write(writer io.Writer, value []uint8) {
	if len(value) > math.MaxInt32 {
		panic("[]uint8 is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverteruint8INSTANCE.write(writer, item)
	}
}

type FfiDestroyerSequenceuint8 struct{}

func (FfiDestroyerSequenceuint8) destroy(sequence []uint8) {
	for _, value := range sequence {
		FfiDestroyeruint8{}.destroy(value)
	}
}
